pipeline {
  agent any

  environment {
    IMAGE = "vickeys/myapp"
    DEPLOYMENT_NAME = "myapp-prod"
    NAMESPACE = "prod"

    // SonarQube setup (configured in Jenkins ‚Üí Manage Jenkins ‚Üí Global Tool Configuration)
    SCANNER_HOME = tool 'sonar-scanner'
  }

  stages {

    // 1Ô∏è‚É£ Checkout Code
    stage('Checkout') {
      steps {
        git branch: "${env.BRANCH_NAME}", url: 'https://github.com/vickeyys/myapp.git'
      }
    }

    // 2Ô∏è‚É£ Unit Tests
    stage('Unit Tests') {
      steps {
        echo "üß™ Running unit tests..."
        // Example: use pytest (for Python) or mvn test (for Java)
        sh 'pytest tests/ || echo "‚ö†Ô∏è No tests found, skipping."'
      }
    }

    // 3Ô∏è‚É£ SonarQube Scan
    stage('SonarQube Analysis') {
      steps {
        withSonarQubeEnv('SonarQube') {
          sh '''
            $SCANNER_HOME/bin/sonar-scanner \
              -Dsonar.projectKey=myapp \
              -Dsonar.sources=. \
              -Dsonar.host.url=http://sonarqube:9000
          '''
        }
      }
    }

    // 4Ô∏è‚É£ Sonar Quality Gate
    stage('Quality Gate') {
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          waitForQualityGate abortPipeline: true
        }
      }
    }

    // 5Ô∏è‚É£ Build Docker Image
    stage('Build Docker Image') {
      steps {
        sh "docker build -t $IMAGE:${env.BUILD_NUMBER} ."
        echo "‚úÖ Build complete for ${env.BRANCH_NAME}"
      }
    }

    // 6Ô∏è‚É£ Trivy Image Scan
    stage('Trivy Security Scan') {
      steps {
        echo "üîç Running Trivy image scan..."
        sh '''
          trivy image --exit-code 1 --severity HIGH,CRITICAL $IMAGE:${env.BUILD_NUMBER} || echo "‚ö†Ô∏è Vulnerabilities found"
        '''
      }
    }

    // 7Ô∏è‚É£ Deployment Logic
    stage('Deploy') {
      steps {
        script {
          if (env.BRANCH_NAME == "dev") {
            echo "üöÄ Deploying to DEV"
            sh "kubectl apply -f manifests/dev/"
          }

          else if (env.BRANCH_NAME == "main") {
            input message: "Approve deployment to QA?", ok: "Deploy"
            echo "üöÄ Deploying to QA"
            sh "kubectl apply -f manifests/qa/"

            input message: "Approve deployment to PROD?", ok: "Deploy"
            echo "üöÄ Deploying to PROD"
            sh '''
              kubectl apply -f manifests/prod/
              kubectl set image deployment/$DEPLOYMENT_NAME myapp=$IMAGE:${env.BUILD_NUMBER} -n $NAMESPACE
              kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=60s
            '''
          }

          else {
            echo "üß™ Feature branch ‚Äî build + test only, no deploy."
          }
        }
      }
    }
  }

  // üîÅ Rollback on Failure
  post {
    failure {
      echo "‚ùå Deployment failed for ${env.BRANCH_NAME}"
      script {
        if (env.BRANCH_NAME == "main") {
          echo "üîÑ Rolling back production to previous stable version..."
          sh '''
            kubectl rollout undo deployment/$DEPLOYMENT_NAME -n $NAMESPACE
            echo "‚úÖ Rollback executed successfully."
          '''
        }
      }
    }

    always {
      echo "üèÅ Pipeline completed for ${env.BRANCH_NAME}"
    }
  }
}
